# push_swap
1. [O] parsing
2. [ ] sort
	- [ ] 작은 pivot(160 등)을 기준으로 작은 것을 stack_b에 푸쉬한다.
	- [ ] 큰 pivot(320 등)을 기준으로 작은 것을 stack_b에 푸쉬한다.
	- 그럼 스택 b에는 (161 ~ 319) (0 ~ 159)가 있고, 스택 a에는 (320 ~ 499)가 있다.
	- 그럼 여기서 어떻게 할까? 내일 이어서 생각하기.
		- 사실 여기서부턴 계속 코드를 돌려보면서 최적화하는 작업이 필요할 것 같다.
 
8/22(월)
- 1~33까지 숫자가 있다고 했을 때, 
  stack_a (23 ~ 33), stack_b (12 ~ 22)
  							 (1 ~ 11)
	- 먼저 pivot을 기준으로 pivot보다 작은거 b로
	- pivot2보다 작은거 b로
	- 처음에 나누는 거는 재귀함수를 사용하는 게 아니라 그냥 구현하기.
	- stack_a 에서 다시 pivot2개를 설정. (여기선 재귀호출함수를 사용하는 게 좋겠다)
	- pivot 25, pivot 28(기존 pivot2 + size / 3)
	- pivot 30, pivot 32	
	- 그럼 stack_a size가 <= 2 작게되는데, 이걸 종료조건으로 하면 stack_a에 2개 정렬하고, 나머지는 stack_b 에 보낸상태가 된다.
	- 그럼 stack_b에는 (30 ~ 31), (28 ~ 29), (25 ~ 27), (22 ~ 24)가 있는데 어떤식으로 해야하지?
		- 기존에 a에서 b로 보낸 크기를 가지고 있는다? (3, 3, 2, 2)
		- 보낸 크기와 pivot값도 기억해야 할 듯? 
		- b에서 a로 보낼 때 크기 2랑 크기 2보다 클 때를 나누어 보낸다??????????????

---

- 정렬 속도가 중요한 게 아니다. 명령어를 가능한 적게 사용하는 게 중요하다.
- 어떻게하면 정렬 효율 좋게 최소한의 명령을 사용할 수 있을까?
	- greedy가 이 문제를 해결하는 데 가장 최적의 해답 같다.
		- 정렬하기 전에 최소한의 갯수를 탐색하니까
	- quick_sort로 이 문제를 해결해본다.
		- 명령어 횟수를 떠나 quick_sort는 시간복잡도가 좋기 때문이다.
- 정렬의 기준이 되는 pivot은 어떻게 설정할까?
	- pivot효율은 중간값이 좋다고 하더라.
		- 2개의 피봇을 사용해서 정렬해보자. (명령어 갯수를 낮추기 위해선 좀 더 비슷한 값끼리 모이게 할 필요가 있다.)
		- pivot값은 어떻게 구할 수 있을까?
			- 500개일 때 ranking을 매기면 1~500등까지 있다. 160등 기준으로 나누고 320등 기준으로 나눈다. 160등, 320 등의 값을 편하게 구하기 위해 정렬하여 ranking을 매긴다.
				- stack_a를 이미 정렬한 <temp> list를 만든다.
				- temp_list를 순회하면서 stack_a 원소들의 ranking을 매길 수 있다. (제일 작은 건 0, 제일 큰 건 size와 같도록)
