# push_swap
1. [O] parsing
2. [ ] sort
	- [ ] 작은 pivot(160 등)을 기준으로 작은 것을 stack_b에 푸쉬한다.
	- [ ] 큰 pivot(320 등)을 기준으로 작은 것을 stack_b에 푸쉬한다.
	- 그럼 스택 b에는 (161 ~ 319) (0 ~ 159)가 있고, 스택 a에는 (320 ~ 499)가 있다.
	- 그럼 여기서 어떻게 할까? 내일 이어서 생각하기.
		- 사실 여기서부턴 계속 코드를 돌려보면서 최적화하는 작업이 필요할 것 같다.
 
8/29(화)
- 차근차근 1~2 1~3 1~4 부터 돌려보는데 1~9에서 터진다 여기서부터 재귀함수가 정확히 돌아야 하기 때문. 지금은 sa가 제대로 안되는 거 같기도 하고, 
- `push_stack_a_r에서 **cmd_list를 받아야 해당 노드의 tool값을 바꿀 수 있는건가? 상관없기도 해보이는데` 일단 메인 로직 완성하고 테스트하기 

- 시간이 많이 걸리는게 코드가 지저분하고, 전에 맞았다고 생각하는 기능함수들에 사소한 에러가 있어서 잡아내는 게 오래걸린다. 
 
- sa가 제대로 안되는지, cmd_list를 앞에서부터 하나씩 없애는 게 제대로 동작 안하는지 내일 다시 봐야겠다. 

8/28(월)
- cmd_list를 손볼 필요가 있다. 연결리스트를 스택처럼 꺼내서 쓰는데, b->a로 보낼때 가장 먼저 보낸 노드, (11~22)를 3덩이로 쪼내서 a가 오는데 현재 코드에선 가장 적은 숫자가 먼저 정렬된다. 가장 적은 숫자가 정렬되는게 아니라. 18~22를 보낸 노드를 먼저 재귀로 정렬완료를 해야하는데, 이 경우를 잡으려면 flag를 쓰든 뭐를 하든 좀 더 생각해봐야겠다.


8/26(금)
- 결국에 코드가 분할정복으로 완성이 되야 하는데.
	- stack_a에 한 덩어리가 stack_b로 가면서 세덩이가 되고, stack_b의 각 덩어리들은 stack_a로 보내지면서 3덩이가 된다. 종료조건은 각 덩이들이 갯수가 2개이하일 때까지(2개이하일 때 정렬한다)
	- t_cmd_node를 스택처럼 사용한다. 
		- pivot, push_count, a->b or b->a flag 정보가 담긴 노드들을 꼬리쪽에서 하나씩 꺼내면서 갯수가 3개 이상이라면 기존 노드를 제거하고, 그 분할정복에 필요한 정보(pivot, push_count..)들을 다시 리스트에 추가해준다.
		- (11, 11, 1) -> (22, 11, 1) -> (25, 3, 1) -> (28, 3, 1) -> (29, 1, 1) -> (30, 1, 1) -> (31, 1, 1) -> (32, 1, 1)
		- (11, 11, 1) -> (22, 11, 1) -> (25, 3, 1) -> (28, 3, 1)
			- (28, 3, 1)노드를 제거하면서 3분할 하면서 생기는 정보들을 push_A에 보낸다 (2개 남았을 때 조건으로 종료조건을 잡았는데, 이게 3개의 덩어리가 쪼개지면서 구체적으로 어떻게 정렬이 될지는 아직 감이 안온다.
- A->B로 보내면서 다시 3분할.. 재귀

8/25(목)
- cmd_list를 만든다.
- cmd_list는 pivot1, pivot2를 이용하여 a->b로 보낸 1a->b로 보냈는지 b->a로 보냈는지 체크하는 것  2pivot 3push_count 을 기록하는 노드를 cmd_list에 푸쉬한다.
- cmd_list를 pop하듯이 하나씩 꺼내서, push_count <=2라면 정렬해버리고, 그렇지 않다면 다시 b->a로 보낸다. push_count가 낮아질 때까지 계속 반복하는데, 이부분을 코드로 구현하는 건 좀 떠 생각해봐야겠다.
- cmd_list에 모든 노드가 없어질 떄까지 반복한다. 한 노드를 없애기 위해선 push_count가 <= 2작을 떄까지 계속 pivot2개로 옆에 스택으로 보낸다.

8/24(수)
- 어떻게 해결해야 하는지 아직 감을 못잡고 있다.
- 1~33 score를 매기고, 
  pivot과 a->b로 보낸 수를 연결리스트에 푸쉬한다.
  (11, 11) -> (22, 11) -> (25, 3) -> (28, 2) -> (29, 1) -> (30, 1) -> (31, 1) -> (32, 1) 
- list가 비어있을 때까지 tail을 꺼내서 푸쉬하는 수가 2보다 적거나 같다면 푸쉬한다.

8/23(화)
- 재귀함수를 사용한다. (인자가 3개 이하 될때 정렬하고 종료하는 식으로 한다)
	- push_stack_b(t_list *list1, t_list *list2, pivot) : 처음에 pivot은 0이다.
	- push_stack_a(t_list *list1, t_list *list2, pivot)
		- 보낸 크기를 기억해서 push_stack_b인자에 추가해야 한다. 왜냐하면 a->b로 보내고, b->a로 보낼 때 a->b로 보낸 크기를 알고 있어야 하기 때문이다.
		- 뭔가 더 필요할 거 같은데 크게 생각이 나진 않는다.

- 정렬
	- 인자가 2개일땐 비교해서 sa연산을 하든가해서 정렬하고, 3개일 때 정렬 케이스를 나눈다.
		- 3개일 때 (1 - 2 - 3) (1 - 3 - 2) (2 - 1 - 3) (2 - 3 - 1) (3 - 1 - 2) (3 - 2 - 1)
	- 처음 스택을 정렬할 경우, 처음이 아닌 경우(정렬된 숫자가 있는 경우)에 정렬 과정이 달라야겠다.

- dangling pointer를 만나서 많이 헤메고 삽질 한 날.
-  pb를 delete_node a, new_node b를 해줬는데 그럴 필요 없이 연결부분만 바꿔주면 된다고 주변사람들이 알려줌.

8/22(월)
- 1~33까지 숫자가 있다고 했을 때, 
  stack_a (23 ~ 33), stack_b (12 ~ 22)
  							 (1 ~ 11)
	- 먼저 pivot을 기준으로 pivot보다 작은거 b로
	- pivot2보다 작은거 b로
	- 처음에 나누는 거는 재귀함수를 사용하는 게 아니라 그냥 구현하기.
	- stack_a 에서 다시 pivot2개를 설정. (여기선 재귀호출함수를 사용하는 게 좋겠다)
	- pivot 25, pivot 28(기존 pivot2 + size / 3)
	- pivot 30, pivot 32	
	- 그럼 stack_a size가 <= 2 작게되는데, 이걸 종료조건으로 하면 stack_a에 2개 정렬하고, 나머지는 stack_b 에 보낸상태가 된다.
	- 그럼 stack_b에는 (30 ~ 31), (28 ~ 29), (25 ~ 27), (22 ~ 24)가 있는데 어떤식으로 해야하지?
		- 기존에 a에서 b로 보낸 크기를 가지고 있는다? (3, 3, 2, 2)
		- 보낸 크기와 pivot값도 기억해야 할 듯? 
		- b에서 a로 보낼 때 크기 2랑 크기 2보다 클 때를 나누어 보낸다??????????????

---

- 정렬 속도가 중요한 게 아니다. 명령어를 가능한 적게 사용하는 게 중요하다.
- 어떻게하면 정렬 효율 좋게 최소한의 명령을 사용할 수 있을까?
	- greedy가 이 문제를 해결하는 데 가장 최적의 해답 같다.
		- 정렬하기 전에 최소한의 갯수를 탐색하니까
	- quick_sort로 이 문제를 해결해본다.
		- 명령어 횟수를 떠나 quick_sort는 시간복잡도가 좋기 때문이다.
- 정렬의 기준이 되는 pivot은 어떻게 설정할까?
	- pivot효율은 중간값이 좋다고 하더라.
		- 2개의 피봇을 사용해서 정렬해보자. (명령어 갯수를 낮추기 위해선 좀 더 비슷한 값끼리 모이게 할 필요가 있다.)
		- pivot값은 어떻게 구할 수 있을까?
			- 500개일 때 ranking을 매기면 1~500등까지 있다. 160등 기준으로 나누고 320등 기준으로 나눈다. 160등, 320 등의 값을 편하게 구하기 위해 정렬하여 ranking을 매긴다.
				- stack_a를 이미 정렬한 <temp> list를 만든다.
				- temp_list를 순회하면서 stack_a 원소들의 ranking을 매길 수 있다. (제일 작은 건 0, 제일 큰 건 size와 같도록)
