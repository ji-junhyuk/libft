# TDL
- [ ] 명령어 갯수를 더 낮춰야 한다.
	- [ ] 지금은 2개 이하일 때만 정렬하는데 3개일 때도 바로 정렬할 수 있게 해야 한다.
	- [ ] stack_a, stack_b에서 정렬된 것들이 아래에 없을 땐 rra(rrb)를 할 필요가 없다.
	- [ ] 해당 노드를 풀 때, a스택에 있는건 정렬되어 있을 때 b로 보내는 과정 없도록 하고, b스택에 있는 것이 역정렬 되어 있을 땐 피봇을 보내는 게 아니라 바로 보낸다?
	- [ ] 추가로 더 있을 듯.
- [ ] 완성되면 leak test
	- 정상적인 경우
		- 인자 없을 때
		- 정렬된 인자들 주어졌을 때
	- 비정상적인 경우
		- 이상한 인자 주어졌을 때
		- exit쓰니깐 크게 생각할 필요 없을듯.
- [ ] norm잡기
- bonus
	- [ ] 체커 만들기

9/4(일)
- 로직은 일단 완성(왕뿌듯)!
- 명령어 갯수
	- 5000개: 97800
	- 1000개: 15800
	- 500개 : 7100
	- 100개 : 1050
	- 50개	: 440
	- 10개	: 55
	- 5개	: 17
- 코드는 이렇게 작동한다. (1~18)을 기준으로 생각하자. 일단 A_stack에서는 B_stack으로 pivot2개를 기준으로 보낸다. (3등분이 된다)
ex) 
				7~12
	13~18		1~6
	<A>			<\B>
- 이떄, 스택의 위치, 피봇값, 보낸 갯수를 저장하는 노드에 해당 정보를 추가한다. 처음에는 (0, 18, 18)에서 시작한다. 이는 앞에서부터 A스택에 18(pivot)보다 작은 갯수가 18개 있다는 것이다. 
- push_stack을 한번 거치면 위에 그림과 같이 pivot_list에는 (1, 6, 6) (1, 12, 6) (0, 18, 6) 노드가 만들어진다. (A스택[0]에서는 작은거부터 보낸다) 이 연결리스트를 스택처럼 사용한다. 즉, pivot_list에 가장 늦게 연결된 (0, 18, 6)부터 꺼내어 정렬한다.
- pivot_list의 노드를 보면 stack_a stack_b에 담겨있는 상태를 알 수 있다.
	- 1. (0, 18, 18)
	- 2. (1, 6, 6) (1, 12, 6) (0, 18, 6) 
	- (0, 18, 6)부터 정렬한다.
	- 3. (1, 14, 2) (1, 16, 2) (0, 18, 2)
		- 2개일 땐 더 나누지 않고 정렬하므로 (0, 18, 2) 노드를 제거하면서 stack_a에는 17, 18이 쌓이게 된다.
		- (1, 16, 2)는 역정렬된 상태로 pa하며 정렬하게 된다. (1, 14, 2)도 마찬가지다.
		- (0, 18, 6) 노드를 제거하면서 13 ~ 18이 정렬된 상태로 A스택에 담겨있다.
	- 마찬가지로 (1, 6, 6) (1, 12, 6)도 스택처럼 하나씩 푼다.
		- (1, 12, 6)은 2덩이로 풀릴 때 (1, 8, 2) (0, 9, 4) 이렇게 된다. 

### 오래 걸렸던 부분
- B에서 A로 보낼 때도 3덩이로 보낼려고 했다. 그렇게하면 A스택엔 중간 덩이 위에 제일 큰 덩이가 올라가있어 제일 큰 덩이를 먼저 정렬한다고 해도 중간에 정렬할 수 없는 중간 값이 끼어져 있다. 그래서 2덩이로 나누는 걸로 해결했다.
- sa를 단순히 데이터 교환하는 식으로 작성했다. 노드의 연결이 뒤바뀌지 않고 데이터 값만 바뀌면 결국 인자를 조금만 더 받아도 숫자가 이상하게 꼬이는데, 알고리즘 문제라 생각하고 알고리즘을 계속 고치려고했음.
- 잘 구현된 연결리스트를 사용해야 하는데, 탄탄하지 않은 자료구조를 쓰다보니 디버깅이 힘들었음.
- pivot_list에 노드를 넣어주는데, 2중 주소로 해줘야 삽입과 삭제가 깔끔히 되는데, 이런 기본적인 개념들이 미숙해서 헤맸다. 
- 재귀 고드를 짜면 작은 수부터 해봐야 하는데 처음부터 33개는 할 수 있다고 생각해서 코드가 더 느리게 나온듯 하다.
  
### 9/2(금)
- delete_node인지, insert_node인지 둘 중 하나 자료구조에서 터지는 거 같은데, 디버깅이 너무 빡세다. 알고리즘은 거의 완성된 거 같은데

### 9/1(목) -> 15일차네. 이렇게 오래할 줄 몰랐는데.
- 코드를 다시 짜야하나? 아이고 안돈다.
- 일단 코드를 고치면, 처음부터 낮은 숫자부터 다시 돌린다. 난 왜이리 재귀적으로 사고하는게 어렵지?
- 로직 정리 한번 해보고, 안되겠다 싶으면 갈아 엎고, 가능하면 코드가 더러워지더라도 짜보자.

### 로직 정리하기, 함수 정리도 해야겠다.
- 처음 정렬은 2피봇으로. 18까지 있으면
```
		7~12
13~18	1~6
[a]		[b]
```
- pivot_list는 이런식으로 만들어진다.
```
```
- 정렬해가면서 pivot_list는 이렇게 바껴간다
```
```


### 8/30(수)
- 1~18에서 터진다. 하나씩 뜯어서 고치면 될듯? 재귀적 사고가 정말 안되는듯. 잘하는 사람은 종료조건만 잡아주면서 돌리던데.
- 그리고 과제 공부하는 시간이 너무 적다. 저녁에 운영체제를 봐야 오전, 오후 과제에 집중할 수 있을듯. 
  
### 8/29(화)
- 차근차근 1~2 1~3 1~4 부터 돌려보는데 1~9에서 터진다 여기서부터 재귀함수가 정확히 돌아야 하기 때문. 지금은 sa가 제대로 안되는 거 같기도 하고, 
- `push_stack_a_r에서 **cmd_list를 받아야 해당 노드의 tool값을 바꿀 수 있는건가? 상관없기도 해보이는데` 일단 메인 로직 완성하고 테스트하기 

- 시간이 많이 걸리는게 코드가 지저분하고, 전에 맞았다고 생각하는 기능함수들에 사소한 에러가 있어서 잡아내는 게 오래걸린다. 
 
- sa가 제대로 안되는지, cmd_list를 앞에서부터 하나씩 없애는 게 제대로 동작 안하는지 내일 다시 봐야겠다. 

### 8/28(월)
- cmd_list를 손볼 필요가 있다. 연결리스트를 스택처럼 꺼내서 쓰는데, b->a로 보낼때 가장 먼저 보낸 노드, (11~22)를 3덩이로 쪼내서 a가 오는데 현재 코드에선 가장 적은 숫자가 먼저 정렬된다. 가장 적은 숫자가 정렬되는게 아니라. 18~22를 보낸 노드를 먼저 재귀로 정렬완료를 해야하는데, 이 경우를 잡으려면 flag를 쓰든 뭐를 하든 좀 더 생각해봐야겠다.


### 8/26(금)
- 결국에 코드가 분할정복으로 완성이 되야 하는데.
	- stack_a에 한 덩어리가 stack_b로 가면서 세덩이가 되고, stack_b의 각 덩어리들은 stack_a로 보내지면서 3덩이가 된다. 종료조건은 각 덩이들이 갯수가 2개이하일 때까지(2개이하일 때 정렬한다)
	- t_cmd_node를 스택처럼 사용한다. 
		- pivot, push_count, a->b or b->a flag 정보가 담긴 노드들을 꼬리쪽에서 하나씩 꺼내면서 갯수가 3개 이상이라면 기존 노드를 제거하고, 그 분할정복에 필요한 정보(pivot, push_count..)들을 다시 리스트에 추가해준다.
		- (11, 11, 1) -> (22, 11, 1) -> (25, 3, 1) -> (28, 3, 1) -> (29, 1, 1) -> (30, 1, 1) -> (31, 1, 1) -> (32, 1, 1)
		- (11, 11, 1) -> (22, 11, 1) -> (25, 3, 1) -> (28, 3, 1)
			- (28, 3, 1)노드를 제거하면서 3분할 하면서 생기는 정보들을 push_A에 보낸다 (2개 남았을 때 조건으로 종료조건을 잡았는데, 이게 3개의 덩어리가 쪼개지면서 구체적으로 어떻게 정렬이 될지는 아직 감이 안온다.
- A->B로 보내면서 다시 3분할.. 재귀

### 8/25(목)
- cmd_list를 만든다.
- cmd_list는 pivot1, pivot2를 이용하여 a->b로 보낸 1a->b로 보냈는지 b->a로 보냈는지 체크하는 것  2pivot 3push_count 을 기록하는 노드를 cmd_list에 푸쉬한다.
- cmd_list를 pop하듯이 하나씩 꺼내서, push_count <=2라면 정렬해버리고, 그렇지 않다면 다시 b->a로 보낸다. push_count가 낮아질 때까지 계속 반복하는데, 이부분을 코드로 구현하는 건 좀 떠 생각해봐야겠다.
- cmd_list에 모든 노드가 없어질 떄까지 반복한다. 한 노드를 없애기 위해선 push_count가 <= 2작을 떄까지 계속 pivot2개로 옆에 스택으로 보낸다.

### 8/24(수)
- 어떻게 해결해야 하는지 아직 감을 못잡고 있다.
- 1~33 score를 매기고, 
  pivot과 a->b로 보낸 수를 연결리스트에 푸쉬한다.
  (11, 11) -> (22, 11) -> (25, 3) -> (28, 2) -> (29, 1) -> (30, 1) -> (31, 1) -> (32, 1) 
- list가 비어있을 때까지 tail을 꺼내서 푸쉬하는 수가 2보다 적거나 같다면 푸쉬한다.

### 8/23(화)
- 재귀함수를 사용한다. (인자가 3개 이하 될때 정렬하고 종료하는 식으로 한다)
	- push_stack_b(t_list *list1, t_list *list2, pivot) : 처음에 pivot은 0이다.
	- push_stack_a(t_list *list1, t_list *list2, pivot)
		- 보낸 크기를 기억해서 push_stack_b인자에 추가해야 한다. 왜냐하면 a->b로 보내고, b->a로 보낼 때 a->b로 보낸 크기를 알고 있어야 하기 때문이다.
		- 뭔가 더 필요할 거 같은데 크게 생각이 나진 않는다.

- 정렬
	- 인자가 2개일땐 비교해서 sa연산을 하든가해서 정렬하고, 3개일 때 정렬 케이스를 나눈다.
		- 3개일 때 (1 - 2 - 3) (1 - 3 - 2) (2 - 1 - 3) (2 - 3 - 1) (3 - 1 - 2) (3 - 2 - 1)
	- 처음 스택을 정렬할 경우, 처음이 아닌 경우(정렬된 숫자가 있는 경우)에 정렬 과정이 달라야겠다.

- dangling pointer를 만나서 많이 헤메고 삽질 한 날.
-  pb를 delete_node a, new_node b를 해줬는데 그럴 필요 없이 연결부분만 바꿔주면 된다고 주변사람들이 알려줌.

### 8/22(월)
- 1~33까지 숫자가 있다고 했을 때, 
  stack_a (23 ~ 33), stack_b (12 ~ 22)
  							 (1 ~ 11)
	- 먼저 pivot을 기준으로 pivot보다 작은거 b로
	- pivot2보다 작은거 b로
	- 처음에 나누는 거는 재귀함수를 사용하는 게 아니라 그냥 구현하기.
	- stack_a 에서 다시 pivot2개를 설정. (여기선 재귀호출함수를 사용하는 게 좋겠다)
	- pivot 25, pivot 28(기존 pivot2 + size / 3)
	- pivot 30, pivot 32	
	- 그럼 stack_a size가 <= 2 작게되는데, 이걸 종료조건으로 하면 stack_a에 2개 정렬하고, 나머지는 stack_b 에 보낸상태가 된다.
	- 그럼 stack_b에는 (30 ~ 31), (28 ~ 29), (25 ~ 27), (22 ~ 24)가 있는데 어떤식으로 해야하지?
		- 기존에 a에서 b로 보낸 크기를 가지고 있는다? (3, 3, 2, 2)
		- 보낸 크기와 pivot값도 기억해야 할 듯? 
		- b에서 a로 보낼 때 크기 2랑 크기 2보다 클 때를 나누어 보낸다??????????????

---

- 정렬 속도가 중요한 게 아니다. 명령어를 가능한 적게 사용하는 게 중요하다.
- 어떻게하면 정렬 효율 좋게 최소한의 명령을 사용할 수 있을까?
	- greedy가 이 문제를 해결하는 데 가장 최적의 해답 같다.
		- 정렬하기 전에 최소한의 갯수를 탐색하니까
	- quick_sort로 이 문제를 해결해본다.
		- 명령어 횟수를 떠나 quick_sort는 시간복잡도가 좋기 때문이다.
- 정렬의 기준이 되는 pivot은 어떻게 설정할까?
	- pivot효율은 중간값이 좋다고 하더라.
		- 2개의 피봇을 사용해서 정렬해보자. (명령어 갯수를 낮추기 위해선 좀 더 비슷한 값끼리 모이게 할 필요가 있다.)
		- pivot값은 어떻게 구할 수 있을까?
			- 500개일 때 ranking을 매기면 1~500등까지 있다. 160등 기준으로 나누고 320등 기준으로 나눈다. 160등, 320 등의 값을 편하게 구하기 위해 정렬하여 ranking을 매긴다.
				- stack_a를 이미 정렬한 <temp> list를 만든다.
				- temp_list를 순회하면서 stack_a 원소들의 ranking을 매길 수 있다. (제일 작은 건 0, 제일 큰 건 size와 같도록)
